'use strict';

/**
 * Class representing an Speaker.
 *
 * @private
 */
class Speaker {
  /**
   * Create a new `Speaker`.
   *
   * @param {String} type The name of the Speaker
   * @param {Object} target A reference to the target to which the Speaker was dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message Speaker.
 *
 * @extends Speaker
 * @private
 */
class MessageSpeaker extends Speaker {
  /**
   * Create a new `MessageSpeaker`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the Speaker was dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close Speaker.
 *
 * @extends Speaker
 * @private
 */
class CloseSpeaker extends Speaker {
  /**
   * Create a new `CloseSpeaker`.
   *
   * @param {Number} code The status code explaining why the connection is being closed
   * @param {String} reason A human-readable string explaining why the connection is closing
   * @param {WebSocket} target A reference to the target to which the Speaker was dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open Speaker.
 *
 * @extends Speaker
 * @private
 */
class OpenSpeaker extends Speaker {
  /**
   * Create a new `OpenSpeaker`.
   *
   * @param {WebSocket} target A reference to the target to which the Speaker was dispatched
   */
  constructor(target) {
    super('open', target);
  }
}

/**
 * Class representing an error Speaker.
 *
 * @extends Speaker
 * @private
 */
class ErrorSpeaker extends Speaker {
  /**
   * Create a new `ErrorSpeaker`.
   *
   * @param {Object} error The error that generated this Speaker
   * @param {WebSocket} target A reference to the target to which the Speaker was dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `SpeakerTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const SpeakerTarget = {
  /**
   * Register an Speaker listener.
   *
   * @param {String} method A string representing the Speaker type to listen for
   * @param {Function} listener The listener to add
   * @public
   */
  addSpeakerListener(method, listener) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageSpeaker(data, this));
    }

    function onClose(code, message) {
      listener.call(this, new CloseSpeaker(code, message, this));
    }

    function onError(error) {
      listener.call(this, new ErrorSpeaker(error, this));
    }

    function onOpen() {
      listener.call(this, new OpenSpeaker(this));
    }

    if (method === 'message') {
      onMessage._listener = listener;
      this.on(method, onMessage);
    } else if (method === 'close') {
      onClose._listener = listener;
      this.on(method, onClose);
    } else if (method === 'error') {
      onError._listener = listener;
      this.on(method, onError);
    } else if (method === 'open') {
      onOpen._listener = listener;
      this.on(method, onOpen);
    } else {
      this.on(method, listener);
    }
  },

  /**
   * Remove an Speaker listener.
   *
   * @param {String} method A string representing the Speaker type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeSpeakerListener(method, listener) {
    const listeners = this.listeners(method);

    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(method, listeners[i]);
      }
    }
  }
};

module.exports = SpeakerTarget;
